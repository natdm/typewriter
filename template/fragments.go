package template

import (
	"log"
	"text/template"
)

// This file contains all the dynamic template fragments for each language.

func init() {
	// Make sure all languages have all templates.
	for _, l := range []Language{Elm, Flow, Typescript} {
		for _, t := range []templateKey{
			header, arrayClose, arrayOpen, basic, comment,
			declaration, fieldClose, fieldName, mapClose,
			mapKey, mapValue, structClose, structOpen} {
			if _, ok := templates[l][t]; !ok {
				log.Fatalf("missing template for language %s, template %s", l, t)
			}
		}
	}
}

// language templates
var templates = map[Language]map[templateKey]string{
	Elm:        elmTemplates,
	Flow:       flowTemplates,
	Typescript: tsTemplates,
}

type templateKey string

// consts for template keys to make sure that what is called for is really a key.
// should only use the below consts to call upon templates.
const (
	header      templateKey = "header"
	arrayOpen               = "arrayOpen"
	arrayClose              = "arrayClose"
	basic                   = "basic"
	comment                 = "comment"
	declaration             = "declaration"
	fieldClose              = "fieldClose"
	fieldName               = "fieldName"
	mapClose                = "mapClose"
	mapKey                  = "mapKey"
	mapValue                = "mapValue"
	structClose             = "structClose"
	structOpen              = "structOpen"
)

// newTemplate returns the template string for a language and a templateKey
func newTemplate(lang Language, t templateKey) (*template.Template, error) {
	return template.New(string(t)).
		Funcs(funcMap).
		Parse(templates[lang][t])
}

var elmTemplates = map[templateKey]string{
	header: `-- Automatically generated by typewriter. Do not edit.
-- http://www.github.com/natdm/typewriter

`,
	arrayOpen:  ` List`,
	arrayClose: ``,
	basic:      ` {{updateElmType .Type}}`,
	comment:    ` {{elmComment .Comment}}`,
	declaration: `
{{elmTypeComment .Comment}}type alias {{.Name}} : `,
	fieldClose: `,`,
	fieldName: `	{{.Name}} :`,
	mapClose:    ``,
	mapKey:      `Dict `,
	mapValue:    ` `,
	structClose: `}`,
	structOpen: `{
`,
}

var flowTemplates = map[templateKey]string{
	header: `// @flow
// Automatically generated by typewriter. Do not edit.
// http://www.github.com/natdm/typewriter

`,
	arrayOpen:  `Array<`,
	arrayClose: `>`,
	basic:      `{{if .Pointer}}?{{end}}{{updateFlowType .Type}}`,
	comment:    `{{flowComment .Comment}}`,
	declaration: `
{{flowTypeComment .Comment}}export type {{.Name}} = `,
	fieldClose: `, `,
	fieldName: `
	{{.Name}}: `,
	mapClose:    ` }`,
	mapKey:      `{ [key: `,
	mapValue:    `]: `,
	structClose: `{{if .Strict}}|}{{else}}}{{end}}`,
	structOpen:  `{{if .Strict}}{| {{else}}{ {{end}}`,
}

var tsTemplates = map[templateKey]string{
	header: `// Automatically generated by typewriter. Do not edit.
// http://www.github.com/natdm/typewriter

`,
	arrayOpen:  `Array<`,
	arrayClose: `>`,
	basic:      `{{if .Pointer}}?{{end}}{{updateTSType .Type}}`,
	comment:    `{{tsComment .Comment}}`,
	declaration: `
{{tsTypeComment .Comment}}type {{.Name}} = `,
	fieldClose: `, `,
	fieldName: `
	{{.Name}}: `,
	mapClose:    ` }`,
	mapKey:      `{ [key: `,
	mapValue:    `]: `,
	structClose: `}`,
	structOpen:  `{`,
}
